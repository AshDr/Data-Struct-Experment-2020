## 线性表

#### 需要注意的 ： 循环链表 + 尾指针 (移动尾指针)    链表是否带头节点

####  双(循环)链表 prior 前向指针  next 后向指针  插入操作 

#### 静态链表 即通过数组实现链表



## 栈 队列 递归

### 链栈（带头和不带头） ： 记得移动top

### 队列 ： 队头始终在第一个元素的前面 head  == tail 时 队空

#### 循环队列 注意如何判满

### 链队列（带队头 不带队头） 出队时有可能变成空队列 这时需要把tail移动到head

**广义表的链式存储 表结构 ：tag hp 表头 tp 表尾  原子结构 ：tag data**

**扩展链表表示法 区别  **

### 串 ：

#### 链串、广义表（线性表的推广） 小写字母为原子 大写字母为子表 取表尾（除去第一个元素 剩下元素构成的子表）



### 查找

#### 二分查找

**1.写二分序**

#### BST删除结点时

##### 1.前驱和后继顶替法注意 特殊处理前驱和后继为删除点的直接子结点的情况

##### 2.重接法左节点直接接删除点的父亲 右节点 跟到左节点的右子树上即删除点的前驱上 特判删除点为根节点的情况  会影响高度

##### 当然也可以反着来 即右节点连到父亲上

#### 平衡二叉树

**1，重点掌握四种旋转，平衡因子的定义** -1 0 1  **左减右** **最低不平衡点**

**2.B树相关概念搞清楚：平衡多叉树 一棵M阶B树每个结点至多m-1个关键字，m棵子树每个非终端结点至少有[m/2]-1个关键字[m/2] 棵子树**

**3.散列表 最常用除留余数法 解决冲突两种方法 往后排(线性探测法 会产生堆积)或者链起来(拉链法)  另外还有ASL（取决于散列函数 处理冲突的方法 装填因子）的计算 除一次就算一次**

### 排序

**1.稳定排序** **不稳定排序**

**2.插入、选择、冒泡、希尔（步长一开始为 n / 2）、快排了解他们的稳定性和代码**

**3.堆排序的调整过程 sift 从n/2开始 初建堆和排序**

**4.归并两种方式  自底向下 、自顶向下常用排序**

**5.partion**

### 树

**1.树的一些基础概念：结点的度、树的度数**

**2.广义表表示**

**3.二叉树的结点数以及不同度数的结点数的计算n0 = n2+1、入度出度之和的计算**

**4.完全二叉树的高度计算 logn + 1，叶子节点的计算**

**5.存储方式： 数组存储、二叉链表表示(*lchild,*rchild,data) 涉及一个指针域的计算、三叉链表**

**6.二叉树的遍历**

**7.线索二叉树利用n+1个空的指针域 指向前驱和后继 再加上ltag rtag标记是儿子还是线索**

**8.先序 1个空的、中序2个空的、后序线索化1个空的**

**9.如何线索化：主要是在于找前驱和后继**

**10.孩子节点表示法、双亲结点、重点是孩子兄弟表示法 (广义表依赖于这种表示法 实际上这种存储方法就是把树转为二叉树存储的方式)**

**11.树和森林转二叉树 左孩子为原来最左的孩子，右孩子为其兄弟  产生的二叉树是唯一的**

**12.二叉树还原树或者森林** 连线 + 抹线 森林没有中序遍历

**13.哈夫曼树 计算WPL 用贪心即可**

**14.哈夫曼编码 报文前缀码长度 = 哈夫曼树的带权路径长度 按照出现次数进行哈夫曼树构造即可** 

### 图 ：

**dfs bfs**

**最小生成树 ： Kruskal Prim**

**最短路 ： Dji、Floyed**

**Topo**

**关键路径 ： 最早发生时间 vet  =  max{vet_pre + w} 最迟发生时间 vlt = min{vlt_suc - w} vet = vlt **